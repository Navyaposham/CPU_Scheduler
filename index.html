<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scheduling Simulator â€” Java Files</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="topbar">
    <div class="container">
      <h1>Scheduling Simulator</h1>
      <p class="subtitle">View: <strong>SchedulingSimulator.java</strong> and <strong>Process.java</strong></p>
    </div>
  </header>

  <main class="container">
    <section class="instructions">
      <h2>How to use</h2>
      <ol>
        <li>Save the two files shown below into your Java project folder as <code>SchedulingSimulator.java</code> and <code>Process.java</code>.</li>
        <li>Compile in terminal: <code>javac *.java</code></li>
        <li>Run: <code>java SchedulingSimulator</code> (or, if you have a different main class, use that). See README in your project for details.</li>
      </ol>
      <p class="hint">This viewer is CSS-only (no execution). To run code you need Java JDK on your machine.</p>
    </section>

    <section class="files">
      <article class="file-card">
        <div class="file-header">
          <div>
            <strong>SchedulingSimulator.java</strong>
            <div class="meta">Simulator that reads input file and performs preemptive-priority + RR scheduling</div>
          </div>
        </div>

        <pre class="code-block" tabindex="0"><code>&lt;!-- SchedulingSimulator.java --&gt;
import java.util.Queue;
import java.util.PriorityQueue;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * The SchedulingSimulator class simulates scheduling of processes in a simple uni-processor CPU.
 */
public class SchedulingSimulator {

    /**
    * A Priority Queue object to keep track of the Ready Queue of the processor.
    */
    public static Queue&lt;Process&gt; readyQueue = new PriorityQueue&lt;Process&gt;();

    /**
    * An integer to keep track of the Round Robin Quantum.
    * User can change this. Default value is 2.
    */
    public static int rndRobQuantum = 2;

    /**
    * Read the input file and generate the input process list.
    *
    * @param  file_path   the file path of the input file
    * @return             the input process list
    */
    public static List&lt;Process&gt; readInputProcessList(String file_path)
      {

        List&lt;String&gt; processStringlist = Collections.emptyList();
        List&lt;Process&gt; processList = new ArrayList&lt;Process&gt;();
        String[] string_parts;
        Process tempProcess;
        char process_name;
        int process_arrival = 0;
        int process_priority = 0;
        int process_burst = 0;

        //read the process information file
        try
        {
            processStringlist = Files.readAllLines(Paths.get(file_path), StandardCharsets.UTF_8);
        }

        catch (IOException e)
        {

          e.printStackTrace();
        }

        //printing the input file
        System.out.println("Input file \n----------");
        Iterator&lt;String&gt; itr = processStringlist.iterator();
        while (itr.hasNext())
        {
            //printing the lines of input file
            System.out.println(itr.next());
        }

        //generating the process list
        itr = processStringlist.iterator();
        while (itr.hasNext())
        {
            string_parts = itr.next().split(" ");
            process_name = string_parts[0].charAt(0);
            process_arrival = Integer.parseInt(string_parts[1]);
            process_priority = Integer.parseInt(string_parts[2]);
            process_burst = Integer.parseInt(string_parts[3]);

            tempProcess = new Process(process_name, process_arrival, process_priority, process_burst);
            processList.add(tempProcess);
        }

        return processList;
      }

    /**
    * Schedule a uni-processor CPU using preemptive-priority.
    *
    * @param  processList   the list of input process
    * @return               the list of Gantt Chart
    */
    public static List&lt;Character&gt; PreemptivePrioritySchedule(List&lt;Process&gt; processList)
    {
        int time = 0;
        int list_index = 0;
        boolean preempt = false;
        boolean roundRobin = false;
        Process newProcess = null;
        Process currentProcess = null;
        Process preemptProcess = null;
        Process completedProcess = null;
        Process nextProcess = null;

        List&lt;Character&gt; ganttChartList = new ArrayList&lt;Character&gt;(1);

        //start
        System.out.print("\nTime: "+time);

        while (time &gt;= 0)
        {

            //check for arrival
            if(list_index &lt; processList.size())
                newProcess = processList.get(list_index);

            if( newProcess.getArrival() == time)
            {
                System.out.print(" &lt;&lt;&lt; Arriving Process "+newProcess.getName()+" with priority="+newProcess.getPriority());

                // put process to the priority Queue
                readyQueue.offer(newProcess);

                if(currentProcess != null &amp;&amp; currentProcess.getPriority() &gt; newProcess.getPriority())
                {
                    preempt = true;
                }
                else if(currentProcess != null &amp;&amp; currentProcess.getPriority() == newProcess.getPriority())
                {
                    //switch to Round Robin
                    System.out.print("\n   ---Switching to Secondary[Round Robin with Q="+ rndRobQuantum + "]---");
                    roundRobin = true;
                    //check if the current process has completed RR quantum
                    if(isRoundRobinCompleted(rndRobQuantum, currentProcess.getName(), ganttChartList))
                        preempt = true;
                    else
                        preempt = false;
                }
                else
                {
                    preempt = false;
                    roundRobin = false;
                }

                //increase only if arrival happens
                list_index++;
            }

            //check I/O completion - TODO

            //check for preemption
            if(preempt)
            {
                //preempting
                preemptProcess = currentProcess;
                readyQueue.offer(preemptProcess);
                System.out.print("\n   ---Preempting Process " + preemptProcess.getName()+"---");
                //dispatching the next process
                currentProcess = readyQueue.poll();
                System.out.print("\n   ---Dispatching Process " + currentProcess.getName()+"---");
                preempt = false;
            }

            //dispatching the process in the queue
            if(currentProcess == null &amp;&amp; readyQueue.size() == 1) {
                currentProcess = readyQueue.poll();
                System.out.print("\n   ---Dispatching Process " + currentProcess.getName()+"---");
            }

            //process running
            if(currentProcess != null)
            {
                currentProcess.run();
                //demo purpose
                System.out.print("\n" + currentProcess.getName()+" Running...");

                //add to Gantt chart
                ganttChartList.add(currentProcess.getName());

                //looking at the next item in queue
                //if equal priority then switch to Round Robin
                nextProcess =  readyQueue.peek();
                if(nextProcess != null &amp;&amp; currentProcess.getPriority() == nextProcess.getPriority())
                {
                    if(!roundRobin)
                        System.out.print("\n   ---Switching to Secondary[Round Robin with Q="+ rndRobQuantum + "]---");
                    roundRobin = true;
                }
                else
                    roundRobin = false;

                //if in RR state AND current process has completed the quantum
                if(roundRobin &amp;&amp; isRoundRobinCompleted(rndRobQuantum, currentProcess.getName(), ganttChartList))
                    preempt = true;
                else
                    preempt = false;

                if(currentProcess.isComplete())
                {
                    //at completion, remove process from queue
                    completedProcess = currentProcess;
                    //update completed time of the completed process
                    completedProcess.setCompleteTime(time+1);
                    //dispatching a new process
                    currentProcess = readyQueue.poll();
                    //ending RR if one of the equal priority processes completes
                    if(roundRobin)
                        System.out.print("\n   ---Ending Secondary[Round Robin with Q="+ rndRobQuantum + "]---");
                    roundRobin = false;
                }

            }

            time++;
            System.out.print("\nTime: " + time);

            //demo purpose
            if(completedProcess != null &amp;&amp; completedProcess.isComplete()) {
                System.out.print(" &gt;&gt;&gt; Process " + completedProcess.getName() + " completed!");

                completedProcess = null;
                if (currentProcess != null)
                    System.out.print("\n   ---Dispatching Process " + currentProcess.getName() + "---");
            }

            //no more processes in ready queue to run
            if(currentProcess == null)
                break;
        }

        return ganttChartList;
    }

    /**
    * Check whether a process has completed the Round Robin quantum.
    *
    * @param  quantum        the Round Robin quantum
    * @param  process_name   the name of the process to check
    * @param  ganttChart     the list of Gantt Chart
    * @return                a boolean status of completion
    */
    public static boolean isRoundRobinCompleted(int quantum, char process_name, List&lt;Character&gt; ganttChart)
    {
        int j = 0;
        for(int i = ganttChart.size()-1; i &gt;= ganttChart.size()-quantum ; i--)
        {
            if(ganttChart.get(i) == process_name)
                j++;
        }
        if(j == quantum)
            return true;

        return false;
    }

    /**
    * Print the Turn Around time of each process and the overall average.
    *
    * @param  processList   the list of input processes
    * @return               none
    */
    public static void printTurnAroundTimeStat(List&lt;Process&gt; processList)
    {
        int total =0;
        int temp_turn =0;

        for(int i = 0; i &lt; processList.size(); i++) {
            temp_turn = processList.get(i).getTurnAroundTime();
            System.out.print("\nTurn Around Time of Process " + processList.get(i).getName() + ": " + temp_turn);
            total = total + temp_turn;
        }
        float avg = (float)total/processList.size();
        System.out.printf("\nAverage Turn Around Time: %1.2f", avg);
    }

    public static void main(String[] args) {

        List&lt;Process&gt; processList = new ArrayList&lt;Process&gt;();
        List&lt;Character&gt; ganttChart = Collections.emptyList();
        String input_file_path = "C:\\Users\\user\\eclipse-workspace\\SchedulingSimulator\\src\\input.txt";
        //user can change this before running the program
        rndRobQuantum = 2;

        //getting the input process list
        processList = readInputProcessList(input_file_path);

        //emptying the Ready Queue
        readyQueue.clear();

        //scheduling the CPU
        ganttChart = PreemptivePrioritySchedule(processList);

        //printing the Gantt chart
        System.out.print("\n\nGantt Chart: |");
        for(int i = 0; i &lt; ganttChart.size(); i++) {
            System.out.print(ganttChart.get(i) + "|");
        }

        //printing Turn Around Time Statistics
        System.out.print("\n\nTurn Around Time Statistics\n----------------------------");
        printTurnAroundTimeStat(processList);

    }
}
</code></pre>
      </article>

      <article class="file-card">
        <div class="file-header">
          <div>
            <strong>Process.java</strong>
            <div class="meta">A lightweight Process class used by the scheduler (implements Comparable)</div>
          </div>
        </div>

        <pre class="code-block" tabindex="0"><code>&lt;!-- Process.java --&gt;
public class Process implements Comparable&lt;Process&gt;{
    private char name;
    private int arrival;
    private int priority;
    private int cpu_burst;
    private boolean complete;
    private int complete_time;

    Process(char name, int arrival, int priority, int cpu_burst)
    {
        this.name = name;
        this.arrival = arrival;
        this.priority = priority;
        this.cpu_burst = cpu_burst;
        this.complete = false;
        this.complete_time = 0;
    }

    public char getName()
    {
        return this.name;
    }

    public int getArrival()
    {
        return this.arrival;
    }

    public int getPriority()
    {
        return this.priority;
    }

    public int getCpuBurst()
    {
        return this.cpu_burst;
    }

    public boolean isComplete()
    {
        return this.complete;
    }

    public int getCompletion()
    {
        return this.complete_time;
    }

    public int getTurnAroundTime()
    {
        return this.complete_time - this.arrival;
    }

    public boolean isRoundRobbinCompleted()
    {
        return true;
    }

    public void setArrival(int arrival)
    {
        this.arrival = arrival;
    }

    public void setPriority(int priority)
    {
        this.priority = priority;
    }

    public void setCpuBurst(int cpu_burst)
    {
        this.cpu_burst = cpu_burst;
    }

    private void setComplete(boolean complete)
    {
        this.complete = complete;
    }

    public void setCompleteTime(int complete_time)
    {
        this.complete_time = complete_time;
    }

    /**
    * Run the process in CPU and reduce the cpu burst time by 1 after each run.
    *
    * @param     none
    * @return    none
    */
    public void run()
    {
        //reduce 1 cup burst from the total
        this.cpu_burst = this.cpu_burst-1;
        if(this.cpu_burst==0)
            this.setComplete(true);
    }

    @Override
    public int compareTo(Process p) {
        if (priority &gt;= p.getPriority())//FCFS
            return 1;
        else if (priority &lt; p.getPriority())//rearranged according to priority
            return -1;
        return 0;
    }

}
</code></pre>
      </article>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small>Tip: copy the code into .java files and compile with <code>javac</code>. This page is a viewer only.</small>
    </div>
  </footer>
</body>
</html>
